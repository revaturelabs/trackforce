package com.revature.services;

import java.io.IOException;
import java.math.BigDecimal;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Observable;
import java.util.Observer;
import java.util.Set;
import java.util.TreeSet;

import javax.ws.rs.Consumes;
import javax.ws.rs.GET;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

import org.hibernate.HibernateException;
import org.hibernate.Session;
import org.hibernate.Transaction;

import com.revature.dao.AssociateDaoHibernate;
import com.revature.dao.ClientDaoImpl;
import com.revature.dao.MarketingStatusDao;
import com.revature.dao.MarketingStatusDaoHibernate;
import com.revature.entity.TfAssociate;
import com.revature.entity.TfClient;
import com.revature.entity.TfMarketingStatus;
import com.revature.model.AssociateInfo;
import com.revature.model.ClientInfo;
import com.revature.model.ClientMappedJSON;
import com.revature.model.CurriculumInfo;
import com.revature.model.CurriculumJSON;
import com.revature.model.MarketingStatusInfo;
import com.revature.utils.HibernateUtil;
import com.revature.utils.LogUtil;
import com.revature.utils.PersistentStorage;

@Path("associates")
<<<<<<< HEAD
public class AssociateService implements Delegate {

	/**
	 * Retrieve information about a specific associate.
	 * 
	 * @param associateid
	 *            - The ID of the associate to get information about
	 * @return - An AssociateInfo object that contains the associate's information.
	 * @throws IOException
	 */
	@GET
	@Path("{associateid}")
	@Produces(MediaType.APPLICATION_JSON)
	public AssociateInfo getAssociate(@PathParam("associateid") BigDecimal associateid) throws IOException {
		Session session = HibernateUtil.getSession().openSession();
		Transaction tx = session.beginTransaction();
		try {
			AssociateDaoHibernate associatedao = new AssociateDaoHibernate();

			AssociateInfo associateinfo = associatedao.getAssociate(associateid, session);

			tx.commit();
			return associateinfo;
		} catch (Exception e) {
			tx.rollback();
			e.printStackTrace();
			throw new IOException("Could not get associate", e);
		} finally {
			session.close();
		}
	}

	/**
	 * Update the marketing status or client of an associate from form data.
	 * 
	 * @param id
	 *            - The ID of the associate to change
	 * @param marketingStatus
	 *            - What to change the associate's marketing status to
	 * @param client
	 *            - What client to change the associate to
	 * @return
	 * @throws IOException
	 */
	@PUT
	@Path("{associateId}/update/{marketingStatus}/{client}")
	@Produces({ MediaType.TEXT_HTML })
	public Response updateAssociate(@PathParam("associateId") String id,
			@PathParam("marketingStatus") String marketingStatus, @PathParam("client") String client)
			throws IOException {
		return updateAssociates(new int[] { Integer.parseInt(id) }, marketingStatus, client);
	}

	/**
	 * Gets a list of all the associates. If an associate has no marketing status or
	 * curriculum, replaces them with blanks. If associate has no client, replaces
	 * it with "None".
	 * 
	 * @return - A Response object with a list of TfAssociate objects.
	 * @throws IOException
	 * @throws HibernateException
	 */
	private Set<AssociateInfo> getAllAssociates() throws IOException {
		Set<AssociateInfo> associates = PersistentStorage.getStorage().getAssociates();
		if (associates == null || associates.isEmpty()) {
			execute();
			return PersistentStorage.getStorage().getAssociates();
		}
		return associates;
	}

	private Map<BigDecimal, AssociateInfo> getAssociates() throws HibernateException, IOException {
		Session session = HibernateUtil.getSession().openSession();
		Transaction tx = session.beginTransaction();
		try {
			Map<BigDecimal, AssociateInfo> tfAssociates = new AssociateDaoHibernate().getAssociates(session);
			PersistentStorage.getStorage().setTotals(AssociateInfo.getTotals());

			session.flush();
			tx.commit();
			return tfAssociates;
		} catch (Exception e) {
			e.printStackTrace();
			LogUtil.logger.error(e);
			session.flush();
			tx.rollback();
			throw new IOException("cannot get associates", e);
		} finally {
			session.close();
		}
	}

	/**
	 * Update the marketing status or client of associates
	 * 
	 * @param ids
	 *            to be updated
	 * @param marketingStatus
	 *            updating to
	 * @param client
	 *            updating to
	 * @return
	 * @throws IOException
	 */
	@PUT
	@Path("/update/{marketingStatus}/{client}")
	@Consumes(MediaType.APPLICATION_JSON)
	public Response updateAssociates(int[] ids, @PathParam("marketingStatus") String marketingStatus,
			@PathParam("client") String client) throws IOException {
		Session session = HibernateUtil.getSession().openSession();
		Transaction tx = session.beginTransaction();

		try {
			int statusId = Integer.parseInt(marketingStatus);
			int clientId = Integer.parseInt(client);

			ClientInfo tfclient = PersistentStorage.getStorage().getClientAsMap().get(new BigDecimal(clientId));
			MarketingStatusInfo msi = PersistentStorage.getStorage().getMarketingAsMap().get(new BigDecimal(statusId));

			if (msi == null) {
				return Response.status(Response.Status.BAD_REQUEST).entity("Invalid marketing status sent.").build();
			}

			Map<BigDecimal, AssociateInfo> map = new HashMap<>();
			for (int id : ids) {
				AssociateInfo ai = PersistentStorage.getStorage().getAssociateAsMap().get(new BigDecimal(id));
				ClientInfo old = PersistentStorage.getStorage().getClientAsMap().get(ai.getClid());

				// subtract old values
				if (old != null) {
					if (ai.getMsid() != null)
						old.getStats().subtractFromMap(ai.getMsid());
					old.getTfAssociates().remove(ai);
					BigDecimal oldms = ai.getMsid();
				}

				// add new values
				// since all the resources are available to us, we can update storage here
				// without having to hit the DB
				BigDecimal oldms = ai.getMsid();
				tfclient.getStats().appendToMap(msi.getId());
				tfclient.getTfAssociates().add(ai);
				ai.setMarketingStatusId(msi.getId());
				ai.setMarketingStatus(msi.getName());
				ai.setClid(tfclient.getId());
				ai.setClient(tfclient.getTfClientName());

				// write to DB
				AssociateDaoHibernate associateDaoHibernate = new AssociateDaoHibernate();
				associateDaoHibernate.updateInfo(session, ai.getId(), msi, tfclient);

				map.put(ai.getId(), ai);
				PersistentStorage.getStorage().getTotals().appendToMap(msi.getId());
				PersistentStorage.getStorage().getTotals().subtractFromMap(oldms);
			}
			session.flush();
			tx.commit();

			// update Persistent storage
			PersistentStorage.getStorage().updateAssociates(map);

			return Response.status(Response.Status.OK).build();
		} catch (Exception e) {
			e.printStackTrace();
			LogUtil.logger.error(e);
			session.flush();
			tx.rollback();
			return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity("Updated the associate's information.")
					.build();
		} finally {
			session.close();
		}
	}

	/**
	 * Returns a Response object from StatusInfoUtil with a List of Map objects as
	 * an entity. The format of the Map objects are as follows: <br>
	 * name: (name of curriculum) <br>
	 * count: (count of desired status)
	 * 
	 * @param statusid
	 *            Status id of the status/stage of associates that the requester
	 *            wants information for.
	 * @return a Response object with a List of Map objects as an entity.
	 * @throws IOException
	 * @throws HibernateException
	 */
	@GET
	@Path("client/{statusid}")
	@Produces({ MediaType.APPLICATION_JSON })
	public Response getClients(@PathParam("statusid") int statusid) throws HibernateException, IOException {
		Set<AssociateInfo> associates = PersistentStorage.getStorage().getAssociates();
		if (associates == null) {
			execute();
			associates = PersistentStorage.getStorage().getAssociates();
		}

		Map<BigDecimal, ClientMappedJSON> map = new HashMap<>();
		for (AssociateInfo ai : associates) {
			if (ai.getMsid().equals(new BigDecimal(statusid))) {
				if (!map.containsKey(ai.getClid())) {
					map.put(ai.getClid(), new ClientMappedJSON());
				}
				if (ai.getClient() != null && !ai.getClid().equals(new BigDecimal(-1))) {
					map.get(ai.getClid()).setCount(map.get(ai.getClid()).getCount() + 1);
					map.get(ai.getClid()).setId(ai.getClid().intValueExact());
					map.get(ai.getClid()).setName(ai.getClient());
				}
			}
		}
		return Response.ok(map.values()).build();
	}

	/**
	 * Returns a Response object from StatusInfoUtil with a List of Map objects as
	 * an entity. The format of the Map objects are as follows: <br>
	 * name: (name of curriculum) <br>
	 * count: (count of desired status)
	 * 
	 * @param statusid
	 *            Status id of the status/stage of associates that the requester
	 *            wants information for.
	 * @return a Response object with a List of Map objects as an entity.
	 * @throws IOException
	 * @throws HibernateException
	 */
	@GET
	@Path("skillset/{statusid}")
	@Produces({ MediaType.APPLICATION_JSON })
	public Response getCurriculumsByStatus(@PathParam("statusid") int statusid) throws HibernateException, IOException {
		Set<AssociateInfo> associates = PersistentStorage.getStorage().getAssociates();
		if (associates == null) {
			execute();
			associates = PersistentStorage.getStorage().getAssociates();
		}

		Map<BigDecimal, CurriculumJSON> map = new HashMap<>();
		Set<AssociateInfo> assocsByStatus = new TreeSet<AssociateInfo>();
		for (AssociateInfo ai : associates) {
			if (ai.getMsid().equals(new BigDecimal(statusid))) {
				if (!map.containsKey(ai.getCurid())) {
					map.put(ai.getCurid(), new CurriculumJSON());
				}
				if (ai.getCurriculumName() != null && !ai.getCurid().equals(new BigDecimal(-1))) {
					map.get(ai.getCurid()).setCount(map.get(ai.getCurid()).getCount() + 1);
					map.get(ai.getCurid()).setId(ai.getCurid().intValueExact());
					map.get(ai.getCurid()).setName(ai.getCurriculumName());
				}
			}
		}
		return Response.ok(map.values()).build();
	}

	// execute delegated task: fetch data from DB and cache it to storage
	@Override
	public synchronized void execute() throws IOException {
		Set<AssociateInfo> ai = PersistentStorage.getStorage().getAssociates();
		if (ai == null || ai.isEmpty())
			PersistentStorage.getStorage().setAssociates(getAssociates());
	}

	@Override
	public <T> Set<T> read(String... args) throws IOException {
		return (Set<T>) getAllAssociates();
	}
}
=======
public class AssociateService {

    private HomeDaoImpl homeDaoImpl = new HomeDaoImpl();

    /**
     * Retrieve information about a specific associate.
     *
     * @param associateid - The ID of the associate to get information about
     * @return - An AssociateInfo object that contains the associate's information.
     * @throws IOException
     */
    @GET
    @Path("{associateid}")
    @Produces(MediaType.APPLICATION_JSON)
    public AssociateInfo getAssociate(@PathParam("associateid") BigDecimal associateid) throws IOException {
        Session session = HibernateUtil.getSession().openSession();
        Transaction tx = session.beginTransaction();
        try {
            AssociateDaoHibernate associatedao = new AssociateDaoHibernate();
            TfAssociate associate = associatedao.getAssociate(associateid);
            AssociateInfo associateinfo = associateToInfo(associate);

            tx.commit();
            return associateinfo;
        } catch (Exception e) {
            tx.rollback();
            e.printStackTrace();
            throw new IOException("Could not get associate", e);
        } finally {
            session.close();
        }
    }

    /**
     * Update the marketing status or client of an associate from form data.
     *
     * @param id              - The ID of the associate to change
     * @param marketingStatus - What to change the associate's marketing status to
     * @param client          - What client to change the associate to
     * @return
     * @throws IOException
     */
    @PUT
    @Path("{associateId}/update/{marketingStatus}/{client}")
    @Produces({MediaType.TEXT_HTML})
    public Response updateAssociate(@PathParam("associateId") String id,
                                    @PathParam("marketingStatus") String marketingStatus, @PathParam("client") String client)
            throws IOException {
        Session session = HibernateUtil.getSession().openSession();
        Transaction tx = session.beginTransaction();
        try {
            MarketingStatusDao marketingStatusDao = new MarketingStatusDaoHibernate();
            TfMarketingStatus status = marketingStatusDao.getMarketingStatus(session, marketingStatus);

            if (status == null) {
                return Response.status(Response.Status.BAD_REQUEST).entity("Invalid marketing status sent.").build();
            }

            ClientDaoImpl clientDaoImpl = new ClientDaoImpl();
            TfClient tfclient = clientDaoImpl.getClient(session, client);

            BigDecimal associateID = new BigDecimal(Integer.parseInt(id));

            AssociateDaoHibernate associateDaoHibernate = new AssociateDaoHibernate();
            associateDaoHibernate.updateInfo(session, associateID, status, tfclient);

            session.flush();
            tx.commit();

            return Response.status(Response.Status.OK).build();
        } catch (Exception e) {
            e.printStackTrace();
            LogUtil.logger.error(e);
            session.flush();
            tx.rollback();
            throw new IOException("can not update associate", e);
        } finally {
            session.close();
        }
    }

    /**
     * Gets a list of all the associates. If an associate has no marketing status or
     * curriculum, replaces them with blanks. If associate has no client, replaces
     * it with "None".
     *
     * @return - A Response object with a list of TfAssociate objects.
     * @throws IOException
     * @throws HibernateException
     */
    @GET
    @Path("all")
    @Produces(MediaType.APPLICATION_JSON)
    public Response getAllAssociates() throws IOException {
        Session session = HibernateUtil.getSession().openSession();
        Transaction tx = session.beginTransaction();
        try {
            List<TfAssociate> tfAssociates = homeDaoImpl.getAllTfAssociates(session);
            Set<AssociateInfo> associateInfos = new TreeSet<>();
            for (TfAssociate tfAssociate : tfAssociates) {
                if (tfAssociate.getTfMarketingStatus() == null || tfAssociate.getTfMarketingStatus().getTfMarketingStatusName().equals("TERMINATED")
                        || tfAssociate.getTfMarketingStatus().getTfMarketingStatusName().equals("DIRECTLY PLACED")) {
                    continue;
                }
                associateInfos.add(associateToInfo(tfAssociate));
            }

            session.flush();
            tx.commit();
            return Response.ok(associateInfos).build();
        } catch (Exception e) {
            e.printStackTrace();
            LogUtil.logger.error(e);
            session.flush();
            tx.rollback();
            throw new IOException("cannot get associates", e);
        } finally {
            session.close();
        }
    }

    /**
     * Update the marketing status or client of associates
     *
     * @param ids             to be updated
     * @param marketingStatus updating to
     * @param client          updating to
     * @return
     * @throws IOException
     */
    @PUT
    @Path("/update/{marketingStatus}/{client}")
    @Consumes(MediaType.APPLICATION_JSON)
    public Response updateAssociates(int[] ids, @PathParam("marketingStatus") String marketingStatus,
                                     @PathParam("client") String client) throws IOException {
        Session session = HibernateUtil.getSession().openSession();
        Transaction tx = session.beginTransaction();

        try {
            MarketingStatusDao marketingStatusDao = new MarketingStatusDaoHibernate();
            TfMarketingStatus status = marketingStatusDao.getMarketingStatus(session, marketingStatus);

            if (status == null) {
                return Response.status(Response.Status.BAD_REQUEST).entity("Invalid marketing status sent.").build();
            }

            ClientDaoImpl clientDaoImpl = new ClientDaoImpl();
            TfClient tfclient = clientDaoImpl.getClient(session, client);

            for (int id : ids) {
                BigDecimal associateID = new BigDecimal(id);

                AssociateDaoHibernate associateDaoHibernate = new AssociateDaoHibernate();
                associateDaoHibernate.updateInfo(session, associateID, status, tfclient);
            }
            session.flush();
            tx.commit();
            return Response.status(Response.Status.OK).build();
        } catch (Exception e) {
            e.printStackTrace();
            LogUtil.logger.error(e);
            session.flush();
            tx.rollback();
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity("Updated the associate's information.").build();
        } finally {
            session.close();
        }
    }

    public AssociateInfo associateToInfo(TfAssociate associate) {
        AssociateInfo associateinfo = new AssociateInfo();
        associateinfo.setId(associate.getTfAssociateId());
        associateinfo.setFirstName(associate.getTfAssociateFirstName());
        associateinfo.setLastName(associate.getTfAssociateLastName());

        if (associate.getTfMarketingStatus() != null) {
            associateinfo.setMarketingStatus(associate.getTfMarketingStatus().getTfMarketingStatusName());
        } else {
            associateinfo.setMarketingStatus("None");
        }

        if (associate.getTfClient() != null) {
            associateinfo.setClient(associate.getTfClient().getTfClientName());
        } else {
            associateinfo.setClient("None");
        }

        if (associate.getTfEndClient() != null) {
            associateinfo.setEndClient(associate.getTfEndClient().getTfEndClientName());
        } else {
            associateinfo.setEndClient("None");
        }
        if (associate.getTfBatch() != null) {
            associateinfo.setBatchName(associate.getTfBatch().getTfBatchName());
            associateinfo.setBatchId(associate.getTfBatch().getTfBatchId());
        } else {
            associateinfo.setBatchName("None");
            associateinfo.setBatchId(null);
        }
        
        return associateinfo;
    }
}
>>>>>>> f476c16a37d31cbb68fbf81a7c93b7799b29d4e3
